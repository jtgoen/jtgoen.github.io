<!DOCTYPE html>
<!-- saved from url=(0066)https://mbostock.github.io/d3/talk/20111116/force-collapsible.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Final Project Prototype</title>
    <link type="text/css" rel="stylesheet" href="./CSS/final/style.css">
    <style type="text/css">

        .link {
            stroke: blue;
        }

        .tweet {
            stroke: #fff;
            fill: purple;
        }

        .hashtag {
            stroke: #fff;
            fill: orange;
        }

    </style>
</head>
<body>
<h2>
    Final Project Prototype (Very Early)
</h2>
<script src="./JS/final/d3.v3.min.js"></script>
<!--<script type="text/javascript" src="./JS/d3.js"></script>
<script type="text/javascript" src="./JS/d3.geom.js"></script>
<script type="text/javascript" src="./JS/d3.layout.js"></script>-->
<script type="text/javascript">

    var width = 1280,
            height = 800,
            radius = 4.5;

    var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

    var force = d3.layout.force()
            .size([width, height]);

    d3.json("./JSON/rise_up_tweets1000.json", function(tweets){
        var nodesByName = {};
        var links = {};

        var count = 0;
        for (var key in tweets) {
            if (count >= 50){
                //break;
            }
            if (tweets.hasOwnProperty(key)) {
                var tweet = tweets[key];
                tweet['hashtags'].forEach(function(hashtag){
                    var d = new Date().getTime();
                    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                        var r = (d + Math.random()*16)%16 | 0;
                        d = Math.floor(d/16);
                        return (c=='x' ? r : (r&0x3|0x8)).toString(16);
                    });
                    links[uuid] = {
                        "source": nodeByName(key, "tweet"),
                        "target": nodeByName(hashtag, "hashtag")
                    };
                });
            }
            count++;
        }

        // Extract the array of nodes from the map by name.
        var nodes = d3.values(nodesByName);
        var linksyeah = d3.values(links);

        // Create the link lines.
        var link = svg.selectAll(".link")
                .data(linksyeah)
                .enter().append("line")
                .attr("class", "link");

        // Create the node circles.
        var node = svg.selectAll(".node")
                .data(nodes)
                .enter().append("circle")
                .attr("class", function(d){
                    if (d.type == "tweet") {
                        return "tweet";
                    }
                    else {
                        return "hashtag";
                    }
                })
                .attr("r", function(d){
                    if (d.type == "tweet") {
                        return radius;
                    }
                    else {
                        console.log(d);
                        return radius;// * (1+Math.random()*10);//(1+Math.log(d.weight));
                    }
                })
                .call(force.drag);
        console.log(node);

        // Start the force layout.
        force
                .nodes(nodes)
                .links(linksyeah)
                .on("tick", tick)
                .start();

        function tick() {
            link.attr("x1", function(d) { return d.source.x; })
                    .attr("y1", function(d) { return d.source.y; })
                    .attr("x2", function(d) { return d.target.x; })
                    .attr("y2", function(d) { return d.target.y; });

            /*node.attr("cx", function(d) { return d.x; })
             .attr("cy", function(d) { return d.y; });*/
            node.attr("cx", function(d) { return d.x /*= Math.max(radius, Math.min(width - radius, d.x))*/; })
                    .attr("cy", function(d) { return d.y /*= Math.max(radius, Math.min(height - radius, d.y))*/; });
        }

        function nodeByName(name, type) {
            return nodesByName[name] || (nodesByName[name] = {name: name, type: type});
        }

    });

    /*var force = d3.layout.force()
     .on("tick", tick)
     .charge(function(d) { return d._children ? -d.size / 100 : -30; })
     .linkDistance(function(d) { return d.target._children ? 80 : 30; })
     .size([w, h - 160]);

     var vis = d3.select("body").append("svg:svg")
     .attr("width", w)
     .attr("height", h);

     d3.json("flare.json", function(json) {
     root = json;
     root.fixed = true;
     root.x = w / 2;
     root.y = h / 2 - 80;
     update();
     });

     function update() {
     var nodes = flatten(root),
     links = d3.layout.tree().links(nodes);

     // Restart the force layout.
     force
     .nodes(nodes)
     .links(links)
     .start();

     // Update the links…
     link = vis.selectAll("line.link")
     .data(links, function(d) { return d.target.id; });

     // Enter any new links.
     link.enter().insert("svg:line", ".node")
     .attr("class", "link")
     .attr("x1", function(d) { return d.source.x; })
     .attr("y1", function(d) { return d.source.y; })
     .attr("x2", function(d) { return d.target.x; })
     .attr("y2", function(d) { return d.target.y; });

     // Exit any old links.
     link.exit().remove();

     // Update the nodes…
     node = vis.selectAll("circle.node")
     .data(nodes, function(d) { return d.id; })
     .style("fill", color);

     node.transition()
     .attr("r", function(d) { return d.children ? 4.5 : Math.sqrt(d.size) / 10; });

     // Enter any new nodes.
     node.enter().append("svg:circle")
     .attr("class", "node")
     .attr("cx", function(d) { return d.x; })
     .attr("cy", function(d) { return d.y; })
     .attr("r", function(d) { return d.children ? 4.5 : Math.sqrt(d.size) / 10; })
     .style("fill", color)
     .on("click", click)
     .call(force.drag);

     // Exit any old nodes.
     node.exit().remove();
     }

     function tick() {
     link.attr("x1", function(d) { return d.source.x; })
     .attr("y1", function(d) { return d.source.y; })
     .attr("x2", function(d) { return d.target.x; })
     .attr("y2", function(d) { return d.target.y; });

     node.attr("cx", function(d) { return d.x; })
     .attr("cy", function(d) { return d.y; });
     }

     // Color leaf nodes orange, and packages white or blue.
     function color(d) {
     return d._children ? "#3182bd" : d.children ? "#c6dbef" : "#fd8d3c";
     }

     // Toggle children on click.
     function click(d) {
     if (d.children) {
     d._children = d.children;
     d.children = null;
     } else {
     d.children = d._children;
     d._children = null;
     }
     update();
     }

     // Returns a list of all nodes under the root.
     function flatten(root) {
     var nodes = [], i = 0;

     function recurse(node) {
     if (node.children) node.size = node.children.reduce(function(p, v) { return p + recurse(v); }, 0);
     if (!node.id) node.id = ++i;
     nodes.push(node);
     return node.size;
     }

     root.size = recurse(root);
     return nodes;
     }*/

</script>
<p>
Filter Hashtags:
<select>
	<option value=""></option>
	<option value="blm1">#BlackLivesMatter</option>
	<option value="blm2">#BLM</option>
	<option value="ruo">#RiseUpOctober</option>
</select>
</p>
</body></html>
